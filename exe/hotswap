#!/usr/bin/env ruby

require "socket"
require "shellwords"

socket_path = ENV.fetch("HOTSWAP_SOCKET", "tmp/sockets/hotswap.sock")
stderr_socket_path = ENV.fetch("HOTSWAP_STDERR_SOCKET", "tmp/sockets/hotswap.stderr.sock")

unless File.exist?(socket_path)
  $stderr.puts "ERROR: socket not found at #{socket_path}"
  exit 1
end

# Connect stderr socket first so it's ready before the command runs
stderr_sock = nil
if File.exist?(stderr_socket_path)
  stderr_sock = UNIXSocket.new(stderr_socket_path)
end

sock = UNIXSocket.new(socket_path)

# Shell-escape args to preserve spaces in file paths
args = ARGV.map { |a| Shellwords.escape(a) }.join(" ")
sock.write(args + "\n")

# Pipe stdin to socket (only if data is being piped in)
writer = nil
if !$stdin.tty?
  writer = Thread.new do
    IO.copy_stream($stdin, sock) rescue nil
    sock.close_write rescue nil
  end
else
  sock.close_write
end

# Pipe stderr socket to local stderr (in background thread)
stderr_reader = nil
if stderr_sock
  stderr_reader = Thread.new do
    IO.copy_stream(stderr_sock, $stderr) rescue nil
  end
end

# Pipe socket output to stdout
IO.copy_stream(sock, $stdout) rescue nil

writer&.join
stderr_reader&.join
stderr_sock&.close rescue nil
sock.close rescue nil
